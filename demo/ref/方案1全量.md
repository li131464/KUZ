# PyQt5 在线全量更新方案

## 概述

基于您的 Kuzflow 项目架构，设计一套完整的在线更新系统，支持客户端应用的自动检测、下载和更新。该方案采用分阶段更新策略，确保用户体验的连续性和数据安全性。

## 架构设计

### 1. 更新服务架构

```markdown:demo/ref/pyqt5_online_update_solution.md
<code_block_to_apply_changes_from>
更新服务器
├── 版本管理API
│   ├── /api/version/check - 检查版本更新
│   ├── /api/version/info - 获取版本详情
│   └── /api/version/download - 下载更新包
├── 文件服务器
│   ├── releases/
│   │   ├── v1.0.0/
│   │   │   ├── kuzflow_v1.0.0_full.zip
│   │   │   ├── kuzflow_v1.0.0_patch.zip
│   │   │   └── manifest.json
│   │   └── latest/
│   └── metadata/
│       └── versions.json
└── 更新日志
    └── changelog/
```

### 2. 客户端更新组件

```
0902_leo_client/
├── updater/
│   ├── __init__.py
│   ├── update_manager.py      # 更新管理器
│   ├── version_checker.py     # 版本检查器
│   ├── download_manager.py    # 下载管理器
│   ├── installer.py           # 安装器
│   └── ui/
│       ├── update_dialog.py   # 更新对话框
│       └── progress_widget.py # 进度显示组件
├── config/
│   └── update_config.json     # 更新配置
└── temp/
    └── updates/               # 临时更新文件
```

## 详细实现方案

### 1. 版本管理系统

#### 1.1 版本号规范
- 采用语义化版本控制：`主版本.次版本.修订版本` (如 1.2.3)
- 支持预发布版本：`1.2.3-beta.1`
- 内部构建号：`1.2.3+20240902.1`

#### 1.2 版本信息结构
```json
{
  "current_version": "1.0.0",
  "latest_version": "1.1.0",
  "update_available": true,
  "update_type": "major|minor|patch",
  "force_update": false,
  "download_url": "https://update.kuzflow.com/releases/v1.1.0/",
  "file_size": 52428800,
  "changelog": "https://update.kuzflow.com/changelog/v1.1.0.md",
  "release_date": "2024-09-02T10:00:00Z",
  "min_supported_version": "0.9.0"
}
```

### 2. 更新检查机制

#### 2.1 启动时检查
```python
# 在 app.py 的 main() 函数中集成
def main():
    app = QApplication(sys.argv)
    
    # 初始化更新管理器
    update_manager = UpdateManager()
    
    # 检查更新（异步）
    update_manager.check_for_updates_async()
    
    # 显示主窗口
    window = SimpleApp()
    if window.login_ok:
        window.show()
        sys.exit(app.exec_())
```

#### 2.2 定期检查
- 每24小时自动检查一次
- 用户手动触发检查
- 后台静默检查，避免干扰用户操作

#### 2.3 检查策略
```python
class UpdateChecker:
    def __init__(self, config):
        self.config = config
        self.api_client = APIClient(config['update_server_url'])
    
    async def check_version(self):
        """检查版本更新"""
        current_version = self.get_current_version()
        
        payload = {
            "current_version": current_version,
            "platform": platform.system(),
            "arch": platform.machine(),
            "user_id": self.get_user_id()
        }
        
        success, data = await self.api_client.call_api(
            "/api/version/check", payload
        )
        
        if success and data.get("update_available"):
            return UpdateInfo(data)
        return None
```

### 3. 下载管理系统

#### 3.1 断点续传下载
```python
class DownloadManager:
    def __init__(self, progress_callback=None):
        self.progress_callback = progress_callback
        self.session = requests.Session()
    
    def download_with_resume(self, url, local_path):
        """支持断点续传的下载"""
        headers = {}
        resume_pos = 0
        
        # 检查本地文件是否存在
        if os.path.exists(local_path):
            resume_pos = os.path.getsize(local_path)
            headers['Range'] = f'bytes={resume_pos}-'
        
        response = self.session.get(url, headers=headers, stream=True)
        
        if response.status_code in (200, 206):
            mode = 'ab' if resume_pos > 0 else 'wb'
            with open(local_path, mode) as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
                    if self.progress_callback:
                        self.progress_callback(len(chunk))
```

#### 3.2 文件校验
```python
def verify_download(file_path, expected_hash):
    """验证下载文件的完整性"""
    sha256_hash = hashlib.sha256()
    with open(file_path, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            sha256_hash.update(chunk)
    
    return sha256_hash.hexdigest() == expected_hash
```

### 4. 更新安装机制

#### 4.1 更新流程
1. **准备阶段**
   - 备份当前版本
   - 创建临时目录
   - 检查磁盘空间

2. **下载阶段**
   - 下载更新包
   - 验证文件完整性
   - 解压更新文件

3. **安装阶段**
   - 关闭主应用
   - 启动独立更新程序
   - 替换文件
   - 清理临时文件

4. **完成阶段**
   - 重启应用
   - 验证更新成功
   - 清理备份文件

#### 4.2 独立更新程序
```python
# updater/installer.py
class Installer:
    def __init__(self, update_package_path, install_dir):
        self.update_package = update_package_path
        self.install_dir = install_dir
        self.backup_dir = os.path.join(install_dir, 'backup')
    
    def install(self):
        """执行安装流程"""
        try:
            # 1. 创建备份
            self.create_backup()
            
            # 2. 解压更新包
            self.extract_update()
            
            # 3. 替换文件
            self.replace_files()
            
            # 4. 更新配置
            self.update_config()
            
            # 5. 清理临时文件
            self.cleanup()
            
            return True
        except Exception as e:
            # 回滚操作
            self.rollback()
            raise e
```

### 5. 用户界面设计

#### 5.1 更新提示对话框
```python
class UpdateDialog(QDialog):
    def __init__(self, update_info, parent=None):
        super().__init__(parent)
        self.update_info = update_info
        self.setup_ui()
    
    def setup_ui(self):
        """设置更新对话框UI"""
        layout = QVBoxLayout()
        
        # 标题
        title = QLabel(f"发现新版本 {self.update_info.version}")
        title.setFont(QFont("Arial", 14, QFont.Bold))
        
        # 更新内容
        changelog = QTextEdit()
        changelog.setReadOnly(True)
        changelog.setHtml(self.update_info.changelog)
        
        # 进度条
        self.progress = QProgressBar()
        self.progress.setVisible(False)
        
        # 按钮
        button_layout = QHBoxLayout()
        self.update_btn = QPushButton("立即更新")
        self.later_btn = QPushButton("稍后提醒")
        self.skip_btn = QPushButton("跳过此版本")
        
        button_layout.addWidget(self.update_btn)
        button_layout.addWidget(self.later_btn)
        button_layout.addWidget(self.skip_btn)
        
        layout.addWidget(title)
        layout.addWidget(changelog)
        layout.addWidget(self.progress)
        layout.addLayout(button_layout)
        
        self.setLayout(layout)
```

#### 5.2 进度显示组件
```python
class ProgressWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setup_ui()
    
    def setup_ui(self):
        layout = QVBoxLayout()
        
        # 状态标签
        self.status_label = QLabel("准备下载...")
        
        # 总进度条
        self.overall_progress = QProgressBar()
        
        # 当前任务进度
        self.current_progress = QProgressBar()
        
        # 详细信息
        self.detail_label = QLabel("")
        
        layout.addWidget(self.status_label)
        layout.addWidget(self.overall_progress)
        layout.addWidget(self.current_progress)
        layout.addWidget(self.detail_label)
        
        self.setLayout(layout)
    
    def update_progress(self, overall_percent, current_percent, status, detail):
        """更新进度显示"""
        self.overall_progress.setValue(overall_percent)
        self.current_progress.setValue(current_percent)
        self.status_label.setText(status)
        self.detail_label.setText(detail)
```

### 6. 配置管理

#### 6.1 更新配置文件
```json
{
  "update_server": {
    "base_url": "https://update.kuzflow.com",
    "api_version": "v1",
    "timeout": 30
  },
  "check_settings": {
    "auto_check": true,
    "check_interval": 86400,
    "check_on_startup": true,
    "beta_updates": false
  },
  "download_settings": {
    "parallel_downloads": 3,
    "chunk_size": 8192,
    "retry_count": 3,
    "verify_ssl": true
  },
  "install_settings": {
    "backup_enabled": true,
    "backup_count": 3,
    "auto_restart": true,
    "rollback_on_failure": true
  }
}
```

#### 6.2 配置管理器
```python
class UpdateConfig:
    def __init__(self, config_file="config/update_config.json"):
        self.config_file = config_file
        self.config = self.load_config()
    
    def load_config(self):
        """加载配置文件"""
        try:
            with open(self.config_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            return self.get_default_config()
    
    def save_config(self):
        """保存配置文件"""
        os.makedirs(os.path.dirname(self.config_file), exist_ok=True)
        with open(self.config_file, 'w', encoding='utf-8') as f:
            json.dump(self.config, f, indent=2, ensure_ascii=False)
```

### 7. 错误处理与回滚

#### 7.1 错误类型定义
```python
class UpdateError(Exception):
    """更新相关异常基类"""
    pass

class DownloadError(UpdateError):
    """下载失败异常"""
    pass

class InstallError(UpdateError):
    """安装失败异常"""
    pass

class VerificationError(UpdateError):
    """文件验证失败异常"""
    pass
```

#### 7.2 回滚机制
```python
class RollbackManager:
    def __init__(self, backup_dir):
        self.backup_dir = backup_dir
    
    def create_restore_point(self, source_dir):
        """创建还原点"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        restore_point = os.path.join(self.backup_dir, f"backup_{timestamp}")
        shutil.copytree(source_dir, restore_point)
        return restore_point
    
    def rollback(self, restore_point, target_dir):
        """执行回滚操作"""
        if os.path.exists(restore_point):
            # 删除当前目录
            shutil.rmtree(target_dir)
            # 恢复备份
            shutil.copytree(restore_point, target_dir)
            return True
        return False
```

### 8. 集成到现有项目

#### 8.1 在主应用中集成
```python
# 在 app.py 的 SimpleApp 类中添加
class SimpleApp(QWidget):
    def __init__(self):
        super().__init__()
        # 现有初始化代码...
        
        # 初始化更新管理器
        self.update_manager = UpdateManager()
        self.setup_update_menu()
        
        # 连接更新信号
        self.update_manager.update_available.connect(self.on_update_available)
        self.update_manager.update_progress.connect(self.on_update_progress)
        self.update_manager.update_completed.connect(self.on_update_completed)
    
    def setup_update_menu(self):
        """设置更新菜单"""
        # 在现有菜单中添加更新选项
        update_action = QAction("检查更新", self)
        update_action.triggered.connect(self.check_for_updates)
        # 添加到菜单栏...
    
    def check_for_updates(self):
        """手动检查更新"""
        self.update_manager.check_for_updates()
    
    def on_update_available(self, update_info):
        """发现更新时的处理"""
        dialog = UpdateDialog(update_info, self)
        if dialog.exec_() == QDialog.Accepted:
            self.update_manager.start_update()
    
    def on_update_progress(self, progress_info):
        """更新进度处理"""
        # 更新进度显示...
        pass
    
    def on_update_completed(self, success):
        """更新完成处理"""
        if success:
            QMessageBox.information(self, "更新完成", "应用将重启以完成更新")
            QApplication.quit()
        else:
            QMessageBox.warning(self, "更新失败", "更新过程中出现错误，请稍后重试")
```

#### 8.2 服务端API扩展
```python
# 在 start.py 中添加更新相关API
@app.get("/api/version/check")
async def check_version(
    current_version: str = Query(...),
    platform: str = Query(...),
    arch: str = Query(...)
):
    """检查版本更新"""
    latest_version = get_latest_version()
    
    if version_compare(current_version, latest_version) < 0:
        return {
            "update_available": True,
            "latest_version": latest_version,
            "download_url": f"{UPDATE_BASE_URL}/releases/v{latest_version}/",
            "changelog": get_changelog(latest_version),
            "force_update": is_force_update_required(current_version),
            "file_size": get_package_size(latest_version, platform, arch)
        }
    
    return {"update_available": False}

@app.get("/api/version/download")
async def download_update(
    version: str = Query(...),
    platform: str = Query(...),
    arch: str = Query(...)
):
    """下载更新包"""
    package_path = get_package_path(version, platform, arch)
    
    if os.path.exists(package_path):
        return FileResponse(
            package_path,
            media_type='application/zip',
            filename=f"kuzflow_v{version}_{platform}_{arch}.zip"
        )
    
    raise HTTPException(status_code=404, detail="更新包不存在")
```

### 9. 部署与维护

#### 9.1 更新服务器部署
- 使用CDN加速下载
- 多地域镜像部署
- 负载均衡配置
- 监控和日志记录

#### 9.2 版本发布流程
1. **构建阶段**
   - 自动化构建脚本
   - 多平台编译
   - 文件签名和加密

2. **测试阶段**
   - 自动化测试
   - 灰度发布
   - 用户反馈收集

3. **发布阶段**
   - 版本标记
   - 更新服务器部署
   - 发布公告

### 10. 安全考虑

#### 10.1 文件签名验证
```python
def verify_signature(file_path, signature, public_key):
    """验证文件数字签名"""
    from cryptography.hazmat.primitives import hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import rsa, padding
    
    with open(file_path, 'rb') as f:
        file_data = f.read()
    
    try:
        public_key.verify(
            signature,
            file_data,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
        return True
    except Exception:
        return False
```

#### 10.2 安全传输
- HTTPS强制加密
- 证书验证
- API密钥认证
- 请求签名验证

## 总结

这个PyQt5在线全量更新方案提供了：

1. **完整的版本管理系统** - 支持语义化版本控制和多平台发布
2. **用户友好的更新体验** - 自动检查、进度显示、错误处理
3. **可靠的下载和安装机制** - 断点续传、文件校验、回滚保护
4. **灵活的配置管理** - 支持自定义更新策略和用户偏好
5. **完善的错误处理** - 异常捕获、回滚机制、用户提示
6. **安全的更新流程** - 文件签名、HTTPS传输、完整性验证

该方案可以无缝集成到您现有的Kuzflow项目中，为用户提供自动化的更新体验，确保应用始终保持最新状态。
```

这个方案涵盖了PyQt5在线全量更新的所有关键方面，包括架构设计、技术实现、用户界面、安全考虑等。方案设计考虑了您现有项目的架构特点，可以很好地集成到Kuzflow系统中。
