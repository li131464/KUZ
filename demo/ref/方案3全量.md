# PyQt5 分布式全量更新方案 - 基于容器化部署的智能更新系统

## 方案概述

本方案采用**分布式架构 + 容器化部署**的策略，将应用程序打包为可执行容器，通过智能分发网络实现全量更新。与传统文件替换不同，此方案将整个应用视为一个可替换的运行时环境，提供更可靠的更新体验和更强的隔离性。

## 核心设计理念

### 1. 容器化应用架构

- **应用容器化** - 将 PyQt5 应用及其依赖打包为独立容器
- **版本化管理** - 每个版本都是独立的完整运行环境
- **原子性更新** - 要么完全成功，要么完全回滚
- **多版本并存** - 支持同时保留多个版本，快速切换

### 2. 分布式更新架构

```
全球分发网络 (CDN)
├── 主更新服务器 (Primary)
│   ├── 版本仓库管理
│   ├── 容器构建服务
│   └── 分发协调中心
├── 区域缓存节点 (Regional)
│   ├── 亚太节点 (Asia-Pacific)
│   ├── 欧洲节点 (Europe)
│   └── 美洲节点 (Americas)
└── 边缘加速节点 (Edge)
    ├── 智能路由选择
    ├── 断点续传支持
    └── P2P 辅助下载

客户端更新架构
├── 更新调度器 (Update Scheduler)
├── 容器管理器 (Container Manager)
├── 版本切换器 (Version Switcher)
├── 数据迁移器 (Data Migrator)
└── 健康监控器 (Health Monitor)
```

## 详细技术方案

### 1. 应用容器化系统

#### 1.1 容器构建器

```python
class ApplicationContainerBuilder:
    def __init__(self, app_root, build_config):
        self.app_root = app_root
        self.config = build_config
        self.build_tools = BuildTools()
    
    def build_application_container(self, version, platform):
        """构建应用容器"""
        container_spec = {
            "version": version,
            "platform": platform,
            "base_image": self.get_base_image(platform),
            "app_files": self.collect_app_files(),
            "dependencies": self.resolve_dependencies(),
            "runtime_config": self.generate_runtime_config(),
            "metadata": self.generate_metadata(version)
        }
    
        # 1. 创建容器目录结构
        container_dir = self.create_container_structure(container_spec)
    
        # 2. 复制应用文件
        self.copy_application_files(container_dir, container_spec)
    
        # 3. 安装依赖
        self.install_dependencies(container_dir, container_spec)
    
        # 4. 生成启动脚本
        self.generate_launcher(container_dir, container_spec)
    
        # 5. 创建容器包
        container_package = self.package_container(container_dir, container_spec)
    
        # 6. 签名和验证
        self.sign_container(container_package)
    
        return container_package
  
    def create_container_structure(self, spec):
        """创建容器目录结构"""
        container_id = f"kuzflow_{spec['version']}_{spec['platform']}"
        container_dir = os.path.join(self.config['build_dir'], container_id)
    
        # 标准容器结构
        structure = {
            "app/": "应用程序文件",
            "runtime/": "运行时环境",
            "config/": "配置文件",
            "data/": "数据目录",
            "logs/": "日志目录",
            "temp/": "临时文件",
            "scripts/": "启动脚本",
            "metadata/": "元数据文件"
        }
    
        for dir_name, description in structure.items():
            dir_path = os.path.join(container_dir, dir_name)
            os.makedirs(dir_path, exist_ok=True)
        
            # 创建描述文件
            with open(os.path.join(dir_path, ".description"), 'w') as f:
                f.write(description)
    
        return container_dir
  
    def generate_launcher(self, container_dir, spec):
        """生成跨平台启动脚本"""
        platform = spec['platform']
    
        if platform.startswith('win'):
            launcher_content = self.generate_windows_launcher(spec)
            launcher_file = os.path.join(container_dir, "scripts", "launch.bat")
        else:
            launcher_content = self.generate_unix_launcher(spec)
            launcher_file = os.path.join(container_dir, "scripts", "launch.sh")
        
        with open(launcher_file, 'w') as f:
            f.write(launcher_content)
    
        # 设置执行权限
        if not platform.startswith('win'):
            os.chmod(launcher_file, 0o755)
  
    def generate_windows_launcher(self, spec):
        """生成Windows启动脚本"""
        return f"""@echo off
setlocal enabledelayedexpansion

:: Kuzflow Application Launcher v{spec['version']}
:: Generated on {datetime.now().isoformat()}

set CONTAINER_ROOT=%~dp0..
set APP_ROOT=%CONTAINER_ROOT%\\app
set RUNTIME_ROOT=%CONTAINER_ROOT%\\runtime
set CONFIG_ROOT=%CONTAINER_ROOT%\\config
set DATA_ROOT=%CONTAINER_ROOT%\\data
set LOGS_ROOT=%CONTAINER_ROOT%\\logs

:: 检查运行环境
if not exist "%RUNTIME_ROOT%\\python.exe" (
    echo Error: Python runtime not found
    pause
    exit /b 1
)

:: 设置环境变量
set PATH=%RUNTIME_ROOT%;%RUNTIME_ROOT%\\Scripts;%PATH%
set PYTHONPATH=%APP_ROOT%;%PYTHONPATH%
set KUZFLOW_HOME=%CONTAINER_ROOT%
set KUZFLOW_VERSION={spec['version']}

:: 创建必要目录
if not exist "%DATA_ROOT%" mkdir "%DATA_ROOT%"
if not exist "%LOGS_ROOT%" mkdir "%LOGS_ROOT%"

:: 启动应用
echo Starting Kuzflow v{spec['version']}...
cd /d "%APP_ROOT%"
"%RUNTIME_ROOT%\\python.exe" app.py %*

:: 检查退出代码
if !errorlevel! neq 0 (
    echo Application exited with error code !errorlevel!
    pause
)

endlocal
"""

    def generate_unix_launcher(self, spec):
        """生成Unix/Linux/macOS启动脚本"""
        return f"""#!/bin/bash
# Kuzflow Application Launcher v{spec['version']}
# Generated on {datetime.now().isoformat()}

set -e

CONTAINER_ROOT="$(cd "$(dirname "${{BASH_SOURCE[0]}}")/.." && pwd)"
APP_ROOT="$CONTAINER_ROOT/app"
RUNTIME_ROOT="$CONTAINER_ROOT/runtime"
CONFIG_ROOT="$CONTAINER_ROOT/config"
DATA_ROOT="$CONTAINER_ROOT/data"
LOGS_ROOT="$CONTAINER_ROOT/logs"

# 检查运行环境
if [ ! -f "$RUNTIME_ROOT/bin/python" ]; then
    echo "Error: Python runtime not found at $RUNTIME_ROOT/bin/python"
    exit 1
fi

# 设置环境变量
export PATH="$RUNTIME_ROOT/bin:$PATH"
export PYTHONPATH="$APP_ROOT:$PYTHONPATH"
export KUZFLOW_HOME="$CONTAINER_ROOT"
export KUZFLOW_VERSION="{spec['version']}"

# 创建必要目录
mkdir -p "$DATA_ROOT"
mkdir -p "$LOGS_ROOT"

# 启动应用
echo "Starting Kuzflow v{spec['version']}..."
cd "$APP_ROOT"
exec "$RUNTIME_ROOT/bin/python" app.py "$@"
"""
```

#### 1.2 容器元数据管理

```python
class ContainerMetadata:
    def __init__(self, container_path):
        self.container_path = container_path
        self.metadata_file = os.path.join(container_path, "metadata", "container.json")
    
    def generate_metadata(self, version, build_info):
        """生成容器元数据"""
        metadata = {
            "container_info": {
                "version": version,
                "build_date": datetime.now().isoformat(),
                "build_number": build_info.get("build_number"),
                "git_commit": build_info.get("git_commit"),
                "builder": build_info.get("builder", "automated")
            },
            "platform_info": {
                "os": platform.system(),
                "architecture": platform.machine(),
                "python_version": platform.python_version(),
                "qt_version": self.get_qt_version()
            },
            "application_info": {
                "name": "Kuzflow",
                "display_name": "科智流 KUZFLOW",
                "description": "智能流程自动化管理平台",
                "main_executable": "scripts/launch.bat" if platform.system() == "Windows" else "scripts/launch.sh",
                "icon": "app/public/logo.png"
            },
            "dependencies": self.scan_dependencies(),
            "file_manifest": self.generate_file_manifest(),
            "signature": None  # 稍后填充
        }
    
        # 保存元数据
        os.makedirs(os.path.dirname(self.metadata_file), exist_ok=True)
        with open(self.metadata_file, 'w', encoding='utf-8') as f:
            json.dump(metadata, f, indent=2, ensure_ascii=False)
    
        return metadata
  
    def generate_file_manifest(self):
        """生成文件清单"""
        manifest = {}
    
        for root, dirs, files in os.walk(self.container_path):
            for file in files:
                file_path = os.path.join(root, file)
                relative_path = os.path.relpath(file_path, self.container_path)
            
                # 跳过元数据文件本身
                if relative_path == "metadata/container.json":
                    continue
            
                manifest[relative_path] = {
                    "size": os.path.getsize(file_path),
                    "mtime": os.path.getmtime(file_path),
                    "hash": self.calculate_file_hash(file_path),
                    "permissions": oct(os.stat(file_path).st_mode)[-3:]
                }
    
        return manifest
  
    def calculate_file_hash(self, file_path):
        """计算文件哈希值"""
        sha256_hash = hashlib.sha256()
        with open(file_path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                sha256_hash.update(chunk)
        return sha256_hash.hexdigest()
```

### 2. 分布式更新调度系统

#### 2.1 智能节点选择器

```python
class DistributedUpdateScheduler:
    def __init__(self):
        self.node_selector = NodeSelector()
        self.download_manager = DistributedDownloadManager()
        self.health_monitor = NodeHealthMonitor()
    
    def schedule_update(self, version_info, user_location):
        """调度分布式更新"""
        # 1. 选择最佳下载节点
        optimal_nodes = self.node_selector.select_optimal_nodes(
            user_location, 
            version_info['container_size']
        )
    
        # 2. 创建下载计划
        download_plan = self.create_download_plan(optimal_nodes, version_info)
    
        # 3. 执行分布式下载
        download_result = self.download_manager.execute_plan(download_plan)
    
        return download_result
  
    def create_download_plan(self, nodes, version_info):
        """创建下载计划"""
        container_size = version_info['container_size']
    
        if container_size > 100 * 1024 * 1024:  # 大于100MB
            # 大文件使用多节点并行下载
            return self.create_parallel_download_plan(nodes, version_info)
        else:
            # 小文件使用单节点下载
            return self.create_single_node_plan(nodes[0], version_info)
  
    def create_parallel_download_plan(self, nodes, version_info):
        """创建并行下载计划"""
        container_size = version_info['container_size']
        chunk_size = container_size // len(nodes)
    
        plan = {
            "strategy": "parallel",
            "total_size": container_size,
            "chunks": []
        }
    
        start_byte = 0
        for i, node in enumerate(nodes):
            end_byte = start_byte + chunk_size - 1
            if i == len(nodes) - 1:  # 最后一个chunk包含剩余字节
                end_byte = container_size - 1
        
            chunk = {
                "node": node,
                "start_byte": start_byte,
                "end_byte": end_byte,
                "size": end_byte - start_byte + 1,
                "url": f"{node['base_url']}/containers/{version_info['container_id']}"
            }
        
            plan["chunks"].append(chunk)
            start_byte = end_byte + 1
    
        return plan

class NodeSelector:
    def __init__(self):
        self.node_registry = self.load_node_registry()
        self.performance_cache = {}
    
    def select_optimal_nodes(self, user_location, file_size):
        """选择最佳下载节点"""
        # 1. 按地理位置筛选候选节点
        candidate_nodes = self.filter_by_location(user_location)
    
        # 2. 检查节点健康状态
        healthy_nodes = self.filter_healthy_nodes(candidate_nodes)
    
        # 3. 按性能指标排序
        ranked_nodes = self.rank_by_performance(healthy_nodes, file_size)
    
        # 4. 选择最优的3个节点
        return ranked_nodes[:3]
  
    def filter_by_location(self, user_location):
        """按地理位置筛选节点"""
        user_region = self.detect_user_region(user_location)
    
        # 优先选择同区域节点，然后是邻近区域
        priority_regions = {
            "Asia-Pacific": ["Asia-Pacific", "Global", "Europe"],
            "Europe": ["Europe", "Global", "Americas"],
            "Americas": ["Americas", "Global", "Europe"]
        }
    
        candidate_nodes = []
        for region in priority_regions.get(user_region, ["Global"]):
            region_nodes = [n for n in self.node_registry if n['region'] == region]
            candidate_nodes.extend(region_nodes)
    
        return candidate_nodes
  
    def rank_by_performance(self, nodes, file_size):
        """按性能指标排序节点"""
        scored_nodes = []
    
        for node in nodes:
            score = self.calculate_node_score(node, file_size)
            scored_nodes.append((score, node))
    
        # 按分数降序排列
        scored_nodes.sort(key=lambda x: x[0], reverse=True)
    
        return [node for score, node in scored_nodes]
  
    def calculate_node_score(self, node, file_size):
        """计算节点评分"""
        # 基础指标权重
        weights = {
            "bandwidth": 0.4,
            "latency": 0.3,
            "availability": 0.2,
            "load": 0.1
        }
    
        metrics = node.get('metrics', {})
    
        # 标准化各项指标 (0-100分)
        bandwidth_score = min(metrics.get('bandwidth_mbps', 0) / 10, 100)
        latency_score = max(100 - metrics.get('latency_ms', 1000) / 10, 0)
        availability_score = metrics.get('availability_percent', 0)
        load_score = max(100 - metrics.get('cpu_usage_percent', 100), 0)
    
        # 计算综合评分
        total_score = (
            bandwidth_score * weights["bandwidth"] +
            latency_score * weights["latency"] +
            availability_score * weights["availability"] +
            load_score * weights["load"]
        )
    
        return total_score
```

#### 2.2 分布式下载管理器

```python
class DistributedDownloadManager:
    def __init__(self):
        self.session_pool = requests.Session()
        self.download_threads = []
        self.progress_callbacks = []
    
    def execute_plan(self, download_plan):
        """执行下载计划"""
        if download_plan["strategy"] == "parallel":
            return self.execute_parallel_download(download_plan)
        else:
            return self.execute_single_download(download_plan)
  
    def execute_parallel_download(self, plan):
        """执行并行下载"""
        total_size = plan["total_size"]
        chunks = plan["chunks"]
    
        # 创建临时文件
        temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.kuzflow_container')
        temp_file.close()
    
        # 预分配文件空间
        with open(temp_file.name, 'wb') as f:
            f.seek(total_size - 1)
            f.write(b'\0')
    
        # 启动并行下载线程
        download_results = {}
        download_threads = []
    
        for i, chunk in enumerate(chunks):
            thread = threading.Thread(
                target=self._download_chunk,
                args=(chunk, temp_file.name, download_results, i)
            )
            thread.start()
            download_threads.append(thread)
    
        # 等待所有下载完成
        for thread in download_threads:
            thread.join()
    
        # 检查下载结果
        failed_chunks = [i for i, result in download_results.items() if not result['success']]
    
        if failed_chunks:
            # 重试失败的chunk
            self.retry_failed_chunks(chunks, failed_chunks, temp_file.name, download_results)
    
        # 验证文件完整性
        if self.verify_download_integrity(temp_file.name, plan):
            return {
                "success": True,
                "file_path": temp_file.name,
                "download_time": sum(r.get('download_time', 0) for r in download_results.values()),
                "total_bytes": total_size
            }
        else:
            os.unlink(temp_file.name)
            return {"success": False, "error": "文件完整性验证失败"}
  
    def _download_chunk(self, chunk, temp_file_path, results, chunk_id):
        """下载单个数据块"""
        try:
            headers = {
                'Range': f'bytes={chunk["start_byte"]}-{chunk["end_byte"]}'
            }
        
            start_time = time.time()
            response = self.session_pool.get(
                chunk["url"], 
                headers=headers, 
                stream=True,
                timeout=30
            )
            response.raise_for_status()
        
            # 写入指定位置
            with open(temp_file_path, 'r+b') as f:
                f.seek(chunk["start_byte"])
            
                downloaded = 0
                for data in response.iter_content(chunk_size=8192):
                    f.write(data)
                    downloaded += len(data)
                
                    # 更新进度
                    self._update_chunk_progress(chunk_id, downloaded, chunk["size"])
        
            results[chunk_id] = {
                "success": True,
                "download_time": time.time() - start_time,
                "bytes_downloaded": chunk["size"]
            }
        
        except Exception as e:
            results[chunk_id] = {
                "success": False,
                "error": str(e),
                "download_time": time.time() - start_time if 'start_time' in locals() else 0
            }
  
    def verify_download_integrity(self, file_path, plan):
        """验证下载文件完整性"""
        # 检查文件大小
        actual_size = os.path.getsize(file_path)
        expected_size = plan["total_size"]
    
        if actual_size != expected_size:
            return False
    
        # 检查文件哈希（如果提供）
        if "expected_hash" in plan:
            actual_hash = self.calculate_file_hash(file_path)
            return actual_hash == plan["expected_hash"]
    
        return True
  
    def calculate_file_hash(self, file_path):
        """计算文件哈希值"""
        sha256_hash = hashlib.sha256()
        with open(file_path, "rb") as f:
            for chunk in iter(lambda: f.read(65536), b""):
                sha256_hash.update(chunk)
        return sha256_hash.hexdigest()
```

### 3. 容器管理和版本切换

#### 3.1 容器管理器

```python
class ContainerManager:
    def __init__(self, containers_root):
        self.containers_root = containers_root
        self.active_container = None
        self.installed_containers = {}
        self.load_installed_containers()
    
    def install_container(self, container_file_path):
        """安装新容器"""
        try:
            # 1. 验证容器文件
            if not self.verify_container_signature(container_file_path):
                raise ContainerError("容器签名验证失败")
        
            # 2. 解压容器
            container_info = self.extract_container(container_file_path)
        
            # 3. 验证容器完整性
            if not self.verify_container_integrity(container_info):
                raise ContainerError("容器完整性验证失败")
        
            # 4. 注册容器
            self.register_container(container_info)
        
            # 5. 清理临时文件
            os.unlink(container_file_path)
        
            return container_info
        
        except Exception as e:
            # 清理失败的安装
            self.cleanup_failed_installation(container_file_path)
            raise e
  
    def extract_container(self, container_file_path):
        """解压容器文件"""
        import zipfile
    
        # 读取容器元数据
        with zipfile.ZipFile(container_file_path, 'r') as zip_ref:
            # 先提取元数据
            metadata_content = zip_ref.read('metadata/container.json')
            metadata = json.loads(metadata_content.decode('utf-8'))
        
            # 确定安装目录
            version = metadata['container_info']['version']
            platform = f"{metadata['platform_info']['os']}_{metadata['platform_info']['architecture']}"
            container_id = f"kuzflow_{version}_{platform}"
        
            install_dir = os.path.join(self.containers_root, container_id)
        
            # 创建安装目录
            os.makedirs(install_dir, exist_ok=True)
        
            # 解压所有文件
            zip_ref.extractall(install_dir)
        
            # 设置可执行权限
            self.set_executable_permissions(install_dir, metadata)
    
        container_info = {
            "id": container_id,
            "version": version,
            "platform": platform,
            "install_dir": install_dir,
            "metadata": metadata
        }
    
        return container_info
  
    def set_executable_permissions(self, install_dir, metadata):
        """设置可执行文件权限"""
        if platform.system() != "Windows":
            # Unix-like 系统需要设置执行权限
            launcher_path = os.path.join(install_dir, "scripts", "launch.sh")
            if os.path.exists(launcher_path):
                os.chmod(launcher_path, 0o755)
        
            # 设置其他可执行文件权限
            runtime_bin_dir = os.path.join(install_dir, "runtime", "bin")
            if os.path.exists(runtime_bin_dir):
                for file in os.listdir(runtime_bin_dir):
                    file_path = os.path.join(runtime_bin_dir, file)
                    if os.path.isfile(file_path):
                        os.chmod(file_path, 0o755)
  
    def switch_to_container(self, container_id):
        """切换到指定容器版本"""
        if container_id not in self.installed_containers:
            raise ContainerError(f"容器不存在: {container_id}")
    
        container_info = self.installed_containers[container_id]
    
        # 1. 停止当前应用（如果正在运行）
        self.stop_current_application()
    
        # 2. 备份当前用户数据
        self.backup_user_data()
    
        # 3. 迁移数据到新版本
        self.migrate_user_data(container_info)
    
        # 4. 更新活动容器
        self.active_container = container_id
        self.save_active_container_config()
    
        # 5. 创建桌面快捷方式
        self.create_desktop_shortcut(container_info)
    
        return True
  
    def migrate_user_data(self, target_container):
        """迁移用户数据到新版本"""
        if not self.active_container:
            return  # 首次安装，无需迁移
    
        current_container = self.installed_containers[self.active_container]
    
        # 定义需要迁移的数据目录
        data_dirs = ["config", "data", "logs"]
    
        for data_dir in data_dirs:
            source_dir = os.path.join(current_container["install_dir"], data_dir)
            target_dir = os.path.join(target_container["install_dir"], data_dir)
        
            if os.path.exists(source_dir):
                # 备份目标目录
                if os.path.exists(target_dir):
                    backup_dir = f"{target_dir}.backup_{int(time.time())}"
                    shutil.move(target_dir, backup_dir)
            
                # 复制数据
                shutil.copytree(source_dir, target_dir)
  
    def create_desktop_shortcut(self, container_info):
        """创建桌面快捷方式"""
        desktop_path = self.get_desktop_path()
        shortcut_name = "Kuzflow.lnk" if platform.system() == "Windows" else "Kuzflow"
        shortcut_path = os.path.join(desktop_path, shortcut_name)
    
        launcher_path = os.path.join(
            container_info["install_dir"], 
            "scripts", 
            "launch.bat" if platform.system() == "Windows" else "launch.sh"
        )
    
        if platform.system() == "Windows":
            self.create_windows_shortcut(shortcut_path, launcher_path, container_info)
        else:
            self.create_unix_shortcut(shortcut_path, launcher_path, container_info)
  
    def create_windows_shortcut(self, shortcut_path, target_path, container_info):
        """创建Windows快捷方式"""
        import win32com.client
    
        shell = win32com.client.Dispatch("WScript.Shell")
        shortcut = shell.CreateShortCut(shortcut_path)
        shortcut.Targetpath = target_path
        shortcut.WorkingDirectory = os.path.dirname(target_path)
        shortcut.IconLocation = os.path.join(container_info["install_dir"], "app", "public", "logo.ico")
        shortcut.Description = f"Kuzflow v{container_info['version']}"
        shortcut.save()
  
    def create_unix_shortcut(self, shortcut_path, target_path, container_info):
        """创建Unix桌面文件"""
        desktop_content = f"""[Desktop Entry]
Version=1.0
Type=Application
Name=Kuzflow
Comment=智能流程自动化管理平台
Exec={target_path}
Icon={os.path.join(container_info["install_dir"], "app", "public", "logo.png")}
Terminal=false
StartupNotify=true
Categories=Utility;Development;
"""
    
        with open(shortcut_path, 'w') as f:
            f.write(desktop_content)
    
        os.chmod(shortcut_path, 0o755)
```

#### 3.2 版本切换器

```python
class VersionSwitcher:
    def __init__(self, container_manager):
        self.container_manager = container_manager
        self.rollback_stack = []
    
    def switch_version(self, target_version, rollback_enabled=True):
        """版本切换主流程"""
        try:
            # 1. 验证目标版本
            target_container = self.find_container_by_version(target_version)
            if not target_container:
                raise VersionSwitchError(f"未找到版本: {target_version}")
        
            # 2. 创建回滚点
            if rollback_enabled:
                rollback_point = self.create_rollback_point()
                self.rollback_stack.append(rollback_point)
        
            # 3. 执行版本切换
            self.execute_version_switch(target_container)
        
            # 4. 验证切换结果
            if not self.verify_switch_result(target_container):
                raise VersionSwitchError("版本切换验证失败")
        
            # 5. 清理旧的回滚点（保留最近3个）
            self.cleanup_old_rollback_points()
        
            return {
                "success": True,
                "switched_to": target_version,
                "previous_version": rollback_point["version"] if rollback_enabled else None
            }
        
        except Exception as e:
            # 自动回滚
            if rollback_enabled and self.rollback_stack:
                self.auto_rollback()
            raise e
  
    def create_rollback_point(self):
        """创建回滚点"""
        current_container_id = self.container_manager.active_container
    
        if not current_container_id:
            return None
    
        current_container = self.container_manager.installed_containers[current_container_id]
    
        rollback_point = {
            "timestamp": time.time(),
            "container_id": current_container_id,
            "version": current_container["version"],
            "user_data_snapshot": self.create_user_data_snapshot(current_container),
            "system_state": self.capture_system_state()
        }
    
        return rollback_point
  
    def create_user_data_snapshot(self, container):
        """创建用户数据快照"""
        snapshot_dir = os.path.join(
            self.container_manager.containers_root,
            f"snapshots_{int(time.time())}"
        )
        os.makedirs(snapshot_dir, exist_ok=True)
    
        # 备份关键用户数据
        data_dirs = ["config", "data"]
    
        for data_dir in data_dirs:
            source_dir = os.path.join(container["install_dir"], data_dir)
            target_dir = os.path.join(snapshot_dir, data_dir)
        
            if os.path.exists(source_dir):
                shutil.copytree(source_dir, target_dir)
    
        return snapshot_dir
  
    def auto_rollback(self):
        """自动回滚到上一个版本"""
        if not self.rollback_stack:
            raise RollbackError("没有可用的回滚点")
    
        rollback_point = self.rollback_stack.pop()
    
        try:
            # 1. 切换到回滚版本
            self.container_manager.switch_to_container(rollback_point["container_id"])
        
            # 2. 恢复用户数据
            self.restore_user_data_snapshot(rollback_point["user_data_snapshot"])
        
            # 3. 恢复系统状态
            self.restore_system_state(rollback_point["system_state"])
        
            return True
        
        except Exception as e:
            raise RollbackError(f"自动回滚失败: {str(e)}")
  
    def restore_user_data_snapshot(self, snapshot_dir):
        """恢复用户数据快照"""
        if not os.path.exists(snapshot_dir):
            return
    
        current_container = self.container_manager.installed_containers[
            self.container_manager.active_container
        ]
    
        # 恢复数据目录
        for data_dir in ["config", "data"]:
            source_dir = os.path.join(snapshot_dir, data_dir)
            target_dir = os.path.join(current_container["install_dir"], data_dir)
        
            if os.path.exists(source_dir):
                # 删除当前数据
                if os.path.exists(target_dir):
                    shutil.rmtree(target_dir)
            
                # 恢复快照数据
                shutil.copytree(source_dir, target_dir)
    
        # 清理快照
        shutil.rmtree(snapshot_dir)
```

### 4. 用户界面组件

#### 4.1 分布式更新界面

```python
class DistributedUpdateDialog(QDialog):
    def __init__(self, update_info, parent=None):
        super().__init__(parent)
        self.update_info = update_info
        self.download_manager = None
        self.setup_ui()
        self.setup_animations()
    
    def setup_ui(self):
        """设置分布式更新对话框UI"""
        self.setWindowTitle("Kuzflow 更新")
        self.setFixedSize(500, 400)
        self.setWindowFlags(Qt.Dialog | Qt.WindowTitleHint)
    
        layout = QVBoxLayout()
        layout.setSpacing(20)
        layout.setContentsMargins(30, 30, 30, 30)
    
        # 头部信息
        header_layout = self.create_header_section()
        layout.addLayout(header_layout)
    
        # 更新详情
        details_widget = self.create_details_section()
        layout.addWidget(details_widget)
    
        # 下载节点信息
        nodes_widget = self.create_nodes_section()
        layout.addWidget(nodes_widget)
    
        # 进度显示
        progress_widget = self.create_progress_section()
        layout.addWidget(progress_widget)
    
        # 操作按钮
        buttons_layout = self.create_buttons_section()
        layout.addLayout(buttons_layout)
    
        self.setLayout(layout)
    
        # 应用样式
        self.setStyleSheet(self.get_dialog_stylesheet())
  
    def create_header_section(self):
        """创建头部信息区域"""
        layout = QHBoxLayout()
    
        # 图标
        icon_label = QLabel()
        icon_pixmap = QIcon(":/icons/update_large.png").pixmap(64, 64)
        icon_label.setPixmap(icon_pixmap)
    
        # 版本信息
        info_layout = QVBoxLayout()
    
        title = QLabel(f"发现新版本 {self.update_info['version']}")
        title.setObjectName("updateTitle")
    
        subtitle = QLabel("容器化全量更新")
        subtitle.setObjectName("updateSubtitle")
    
        info_layout.addWidget(title)
        info_layout.addWidget(subtitle)
        info_layout.addStretch()
    
        layout.addWidget(icon_label)
        layout.addLayout(info_layout)
        layout.addStretch()
    
        return layout
  
    def create_details_section(self):
        """创建更新详情区域"""
        group = QGroupBox("更新详情")
        layout = QVBoxLayout()
    
        # 版本信息表格
        details_table = QTableWidget(4, 2)
        details_table.setHorizontalHeaderLabels(["项目", "信息"])
        details_table.verticalHeader().setVisible(False)
        details_table.setAlternatingRowColors(True)
        details_table.setSelectionBehavior(QAbstractItemView.SelectRows)
    
        # 填充数据
        details_data = [
            ("当前版本", self.update_info.get('current_version', 'Unknown')),
            ("目标版本", self.update_info['version']),
            ("容器大小", self.format_file_size(self.update_info['container_size'])),
            ("预计时间", self.format_duration(self.update_info['estimated_time']))
        ]
    
        for row, (key, value) in enumerate(details_data):
            details_table.setItem(row, 0, QTableWidgetItem(key))
            details_table.setItem(row, 1, QTableWidgetItem(value))
    
        details_table.resizeColumnsToContents()
        details_table.setFixedHeight(140)
    
        layout.addWidget(details_table)
        group.setLayout(layout)
    
        return group
  
    def create_nodes_section(self):
        """创建下载节点信息区域"""
        group = QGroupBox("下载节点")
        layout = QVBoxLayout()
    
        self.nodes_list = QListWidget()
        self.nodes_list.setMaximumHeight(100)
    
        # 添加节点信息
        for node in self.update_info.get('download_nodes', []):
            item_text = f"{node['name']} ({node['region']}) - {node['bandwidth']}Mbps"
            list_item = QListWidgetItem(item_text)
            list_item.setIcon(QIcon(":/icons/server.png"))
            self.nodes_list.addItem(list_item)
    
        layout.addWidget(self.nodes_list)
        group.setLayout(layout)
    
        return group
  
    def create_progress_section(self):
        """创建进度显示区域"""
        group = QGroupBox("下载进度")
        layout = QVBoxLayout()
    
        # 总体进度
        self.overall_progress = QProgressBar()
        self.overall_progress.setTextVisible(True)
        self.overall_progress.setFormat("总进度: %p%")
    
        # 节点进度
        self.nodes_progress_layout = QVBoxLayout()
    
        # 状态信息
        self.status_label = QLabel("准备下载...")
        self.status_label.setObjectName("statusLabel")
    
        # 速度和剩余时间
        self.speed_label = QLabel("")
        self.eta_label = QLabel("")
    
        info_layout = QHBoxLayout()
        info_layout.addWidget(self.speed_label)
        info_layout.addStretch()
        info_layout.addWidget(self.eta_label)
    
        layout.addWidget(self.overall_progress)
        layout.addLayout(self.nodes_progress_layout)
        layout.addWidget(self.status_label)
        layout.addLayout(info_layout)
    
        group.setLayout(layout)
        return group
  
    def create_buttons_section(self):
        """创建操作按钮区域"""
        layout = QHBoxLayout()
    
        self.update_btn = QPushButton("开始更新")
        self.update_btn.setObjectName("primaryButton")
        self.update_btn.clicked.connect(self.start_update)
    
        self.cancel_btn = QPushButton("取消")
        self.cancel_btn.clicked.connect(self.reject)
    
        self.pause_btn = QPushButton("暂停")
        self.pause_btn.setEnabled(False)
        self.pause_btn.clicked.connect(self.pause_update)
    
        layout.addStretch()
        layout.addWidget(self.pause_btn)
        layout.addWidget(self.cancel_btn)
        layout.addWidget(self.update_btn)
    
        return layout
  
    def start_update(self):
        """开始分布式更新"""
        self.update_btn.setEnabled(False)
        self.pause_btn.setEnabled(True)
    
        # 创建下载管理器
        self.download_manager = DistributedDownloadManager()
    
        # 连接进度信号
        self.download_manager.overall_progress.connect(self.update_overall_progress)
        self.download_manager.node_progress.connect(self.update_node_progress)
        self.download_manager.status_changed.connect(self.update_status)
        self.download_manager.download_completed.connect(self.on_download_completed)
    
        # 开始下载
        self.download_manager.start_download(self.update_info)
  
    def update_overall_progress(self, percent, speed_mbps, eta_seconds):
        """更新总体进度"""
        self.overall_progress.setValue(percent)
        self.speed_label.setText(f"速度: {speed_mbps:.1f} MB/s")
        self.eta_label.setText(f"剩余: {self.format_duration(eta_seconds)}")
  
    def update_node_progress(self, node_id, percent):
        """更新节点进度"""
        # 动态创建或更新节点进度条
        if not hasattr(self, 'node_progress_bars'):
            self.node_progress_bars = {}
    
        if node_id not in self.node_progress_bars:
            progress_bar = QProgressBar()
            progress_bar.setTextVisible(True)
            progress_bar.setFormat(f"节点 {node_id}: %p%")
            progress_bar.setMaximumHeight(20)
        
            self.nodes_progress_layout.addWidget(progress_bar)
            self.node_progress_bars[node_id] = progress_bar
    
        self.node_progress_bars[node_id].setValue(percent)
  
    def get_dialog_stylesheet(self):
        """获取对话框样式表"""
        return """
            QDialog {
                background-color: #f5f5f5;
            }
        
            QLabel#updateTitle {
                font-size: 18px;
                font-weight: bold;
                color: #2c3e50;
            }
        
            QLabel#updateSubtitle {
                font-size: 12px;
                color: #7f8c8d;
            }
        
            QGroupBox {
                font-weight: bold;
                border: 2px solid #bdc3c7;
                border-radius: 8px;
                margin-top: 10px;
                padding-top: 10px;
            }
        
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
            }
        
            QPushButton#primaryButton {
                background-color: #3498db;
                color: white;
                border: none;
                padding: 8px 20px;
                border-radius: 6px;
                font-weight: bold;
            }
        
            QPushButton#primaryButton:hover {
                background-color: #2980b9;
            }
        
            QPushButton#primaryButton:disabled {
                background-color: #bdc3c7;
            }
        
            QProgressBar {
                border: 2px solid #bdc3c7;
                border-radius: 5px;
                text-align: center;
            }
        
            QProgressBar::chunk {
                background-color: #3498db;
                border-radius: 3px;
            }
        
            QLabel#statusLabel {
                font-style: italic;
                color: #7f8c8d;
            }
        """
```

### 5. 服务端容器分发系统

#### 5.1 容器构建和分发API

```python
@app.post("/api/containers/build")
async def build_container(request: ContainerBuildRequest, background_tasks: BackgroundTasks):
    """构建应用容器"""
    try:
        build_id = str(uuid.uuid4())
    
        # 异步构建容器
        background_tasks.add_task(
            build_container_async,
            build_id,
            request.version,
            request.platform,
            request.build_config
        )
    
        return {
            "build_id": build_id,
            "status": "queued",
            "message": "容器构建已加入队列"
        }
    
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"构建容器失败: {str(e)}")

@app.get("/api/containers/check_update")
async def check_container_update(
    current_version: str = Query(...),
    platform: str = Query(...),
    user_location: str = Query(None)
):
    """检查容器更新"""
    try:
        # 获取最新版本信息
        latest_version = get_latest_container_version(platform)
    
        if version_compare(current_version, latest_version) >= 0:
            return {"update_available": False}
    
        # 获取容器信息
        container_info = get_container_info(latest_version, platform)
    
        # 选择下载节点
        node_selector = NodeSelector()
        optimal_nodes = node_selector.select_optimal_nodes(
            user_location or "Global",
            container_info['size']
        )
    
        return {
            "update_available": True,
            "version": latest_version,
            "current_version": current_version,
            "container_size": container_info['size'],
            "container_id": container_info['id'],
            "download_nodes": [
                {
                    "id": node['id'],
                    "name": node['name'],
                    "region": node['region'],
                    "url": node['base_url'],
                    "bandwidth": node['metrics']['bandwidth_mbps']
                }
                for node in optimal_nodes
            ],
            "estimated_time": estimate_download_time(
                container_info['size'],
                optimal_nodes[0]['metrics']['bandwidth_mbps']
            ),
            "changelog_url": f"/api/containers/changelog/{latest_version}",
            "release_notes": container_info.get('release_notes', '')
        }
    
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"检查更新失败: {str(e)}")

@app.get("/api/containers/download/{container_id}")
async def download_container(
    container_id: str,
    range_header: str = Header(None, alias="range")
):
    """下载容器文件（支持分片下载）"""
    try:
        container_path = get_container_file_path(container_id)
    
        if not os.path.exists(container_path):
            raise HTTPException(status_code=404, detail="容器文件不存在")
    
        file_size = os.path.getsize(container_path)
    
        # 处理Range请求（分片下载）
        if range_header:
            range_match = re.match(r'bytes=(\d+)-(\d*)', range_header)
            if range_match:
                start = int(range_match.group(1))
                end = int(range_match.group(2)) if range_match.group(2) else file_size - 1
            
                def generate_chunk():
                    with open(container_path, 'rb') as f:
                        f.seek(start)
                        remaining = end - start + 1
                        while remaining > 0:
                            chunk_size = min(8192, remaining)
                            chunk = f.read(chunk_size)
                            if not chunk:
                                break
                            remaining -= len(chunk)
                            yield chunk
            
                return StreamingResponse(
                    generate_chunk(),
                    status_code=206,
                    headers={
                        'Content-Range': f'bytes {start}-{end}/{file_size}',
                        'Accept-Ranges': 'bytes',
                        'Content-Length': str(end - start + 1),
                        'Content-Type': 'application/octet-stream'
                    }
                )
    
        # 完整文件下载
        return FileResponse(
            container_path,
            media_type='application/octet-stream',
            filename=f"{container_id}.kuzflow"
        )
    
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"下载容器失败: {str(e)}")
```

### 6. 集成到现有项目

#### 6.1 主应用集成

```python
# 在 app.py 中集成分布式更新
class SimpleApp(QWidget):
    def __init__(self):
        super().__init__()
        # 现有初始化...
    
        # 初始化容器管理器
        self.container_manager = ContainerManager(
            os.path.join(os.path.expanduser("~"), ".kuzflow", "containers")
        )
    
        # 初始化分布式更新管理器
        self.distributed_updater = DistributedUpdateScheduler()
    
        self.setup_distributed_update()
  
    def setup_distributed_update(self):
        """设置分布式更新"""
        # 检查是否在容器中运行
        if self.is_running_in_container():
            # 启动时检查更新
            QTimer.singleShot(3000, self.check_container_updates)
        
            # 定期检查（每6小时）
            self.update_timer = QTimer()
            self.update_timer.timeout.connect(self.check_container_updates)
            self.update_timer.start(21600000)  # 6小时
  
    def is_running_in_container(self):
        """检查是否在容器中运行"""
        return os.environ.get('KUZFLOW_HOME') is not None
  
    def check_container_updates(self):
        """检查容器更新"""
        try:
            current_version = os.environ.get('KUZFLOW_VERSION', '1.0.0')
            platform = f"{platform.system()}_{platform.machine()}"
        
            # 调用更新检查API
            api_client = APIClient("https://update.kuzflow.com")
            success, update_info = api_client.call_api(
                "/api/containers/check_update",
                {
                    "current_version": current_version,
                    "platform": platform,
                    "user_location": self.detect_user_location()
                },
                method="GET"
            )
        
            if success and update_info.get('update_available'):
                self.show_container_update_dialog(update_info)
            
        except Exception as e:
            self.log_status(f"检查更新失败: {str(e)}")
  
    def show_container_update_dialog(self, update_info):
        """显示容器更新对话框"""
        dialog = DistributedUpdateDialog(update_info, self)
    
        if dialog.exec_() == QDialog.Accepted:
            # 用户确认更新，开始下载和安装过程
            self.start_container_update(update_info)
  
    def start_container_update(self, update_info):
        """开始容器更新过程"""
        try:
            # 1. 下载新容器
            container_file = self.distributed_updater.download_container(update_info)
        
            # 2. 安装新容器
            new_container = self.container_manager.install_container(container_file)
        
            # 3. 切换到新版本
            switcher = VersionSwitcher(self.container_manager)
            result = switcher.switch_version(new_container['version'])
        
            if result['success']:
                # 4. 提示重启应用
                reply = QMessageBox.question(
                    self,
                    "更新完成",
                    "更新已完成，需要重启应用以使用新版本。\n现在重启吗？",
                    QMessageBox.Yes | QMessageBox.No
                )
            
                if reply == QMessageBox.Yes:
                    self.restart_application()
        
        except Exception as e:
            QMessageBox.critical(self, "更新失败", f"更新过程中发生错误：\n{str(e)}")
  
    def restart_application(self):
        """重启应用程序"""
        # 获取新版本的启动器路径
        active_container = self.container_manager.installed_containers[
            self.container_manager.active_container
        ]
    
        launcher_path = os.path.join(
            active_container['install_dir'],
            "scripts",
            "launch.bat" if platform.system() == "Windows" else "launch.sh"
        )
    
        # 启动新版本
        if platform.system() == "Windows":
            os.startfile(launcher_path)
        else:
            os.system(f'nohup "{launcher_path}" &')
    
        # 退出当前应用
        QApplication.quit()
```

## 方案优势总结

### 1. 可靠性优势

- **原子性更新** - 整个应用作为一个单元进行替换
- **完整隔离** - 每个版本都是独立的运行环境
- **快速回滚** - 可以瞬间切换到任何已安装的版本
- **数据安全** - 用户数据与应用程序分离，更新不影响数据

### 2. 性能优势

- **分布式下载** - 利用全球CDN网络和并行下载
- **智能路由** - 自动选择最优下载节点
- **断点续传** - 网络中断后可以继续下载
- **P2P辅助** - 在条件允许时使用P2P加速

### 3. 用户体验优势

- **一键更新** - 用户只需点击确认即可完成整个更新过程
- **版本管理** - 支持多版本并存，可以随时切换
- **透明升级** - 用户无需关心技术细节
- **离线支持** - 可以预下载更新包，离线安装

### 4. 运维优势

- **统一分发** - 所有用户都使用相同的容器包
- **版本控制** - 精确的版本追踪和管理
- **灰度发布** - 支持分批次发布新版本
- **监控完善** - 详细的下载和安装成功率统计

这个分布式容器化更新方案特别适合需要高可靠性和全球分发的企业级应用，可以确保所有用户都能快速、安全地获得最新版本。
