### 目标
- 新增一个“流程”（服务端配置的任务）
- 注册一个“操作”（客户端可执行的步骤类型，必要时配合服务端 API）

### 新增流程（Process）
1. 在服务端 `server/start.py` 的 `PROCESS_DB` 中新增任务配置：
   - 必填字段：`task_name`、`description`、`steps`（数组）
   - 每个 `step` 必含：`step_id`（从 1 递增）、`step_type`、`step_name`、`params`
   - 若需引用前一步结果：在 `params` 增加 `use_previous_result: true` 与 `source_step: 上一步 id`

   示例：
   ```python
   "我的新流程": {
       "task_name": "我的新流程",
       "description": "演示如何新增流程",
       "steps": [
           { "step_id": 1, "step_type": "click", "step_name": "点击搜索框", "params": { "target_description": "浏览器搜索框" } },
           { "step_id": 2, "step_type": "input", "step_name": "输入关键词并回车", "params": { "text": "OpenAI", "press_enter": True } },
           { "step_id": 3, "step_type": "wait", "step_name": "等待页面加载", "params": { "wait_time": 2.0 } },
           { "step_id": 4, "step_type": "drag", "step_name": "拖拽选择内容", "params": { "target_description": "抖音用户信息区域" } },
           { "step_id": 5, "step_type": "llm_process", "step_name": "LLM处理", "params": { "use_previous_result": True, "source_step": 4 } },
           { "step_id": 6, "step_type": "feishu_write", "step_name": "写入飞书", "params": { "use_previous_result": True, "source_step": 5, "source": "我的新流程" } }
       ]
   }
   ```

2. 客户端通过 `/api/get_process` 拉取并执行：
   ```python
   from manipulate import execute_process
   execute_process(task_name="我的新流程", log_callback=print, server_url="https://121.4.65.242")
   ```

3. 验证（可选）：
   ```bash
   curl -k https://121.4.65.242/api/get_process \
     -X POST -H "Content-Type: application/json" \
     -d '{"task_name":"我的新流程"}'
   ```

### 注册操作（Operation）
新增一个操作需要三步：客户端实现 → 执行器注册 →（可选）服务端 API。

1) 客户端实现（`client/manipulate/my_operation.py`）：
```python
def execute_my_operation(params, step_results, api_client, log_callback=None) -> tuple[bool, dict|None]:
    # 读取入参 params
    # if params.get('use_previous_result'):
    #     source_step = params['source_step']
    #     prev = step_results[source_step]
    # 业务逻辑 ...
    return True, {"my_key": "my_value"}
```

2) 执行器注册（`client/manipulate/executor.py`）：
```python
from .my_operation import execute_my_operation

# ...
elif step_type == "my_operation":
    return execute_my_operation(params, step_results, api_client, api_client.log)
```

3) 导出（可选，`client/manipulate/__init__.py`）：
```python
from .my_operation import execute_my_operation

__all__ = [
  # ...
  'execute_my_operation'
]
```

4) 服务端 API（可选，`server/start.py`）：
```python
from fastapi import BackgroundTasks

@app.post("/api/my_operation")
async def my_operation_api(body: dict, background_tasks: BackgroundTasks):
    # 计算/转发/异步任务
    return {"ok": True, "data": {...}}
```

### 步骤数据传递
- 执行器会把每步结果存入 `step_results[step_id]`
- 下游步骤通过 `params.use_previous_result + params.source_step` 读取
- 约定字段：
  - 识别截图：`recognized_text`
  - 拖拽复制：`selected_text`
  - LLM 结果：`processed_result`（严格 JSON 字符串，如 `{"用户名称":"...","粉丝数":"..."}`）
  - 保存文件：内部处理
  - 飞书写入：读取 `processed_result`，异步写入

### 现有操作速览
- `click`：`/api/click/xy` → `pyautogui.click`
- `input`：复制粘贴（`command+a` → `pyperclip.copy` → `command+v`），支持 `press_enter`
- `wait`：`time.sleep(wait_time)`
- `rec_get_xy`：`/api/rec/get_xy` 获取目标区域
- `rec_rec`：本地截图 → `/api/rec/rec`（返回文本）
- `drag`：`/api/drag` 获取起止坐标 → 鼠标拖拽 + `command+c` 复制 → 读剪贴板
- `llm_process`：`/api/llm/process`，模型直出严格 JSON（“用户名称”“粉丝数”）
- `save_result`：只保存 `processed_result`
- `feishu_write`：`/api/feishu/write` 异步写入飞书（立即返回）

### 注意
- `step_id` 递增且唯一
- `step_type` 必须在执行器有分支
- macOS 使用 `command`，跨平台时注意兼容
- 长耗时建议服务端异步，客户端合理超时
- LLM 输出已强约束为严格 JSON，服务器不再做格式归一化